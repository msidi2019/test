<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/3.4.2/gl-matrix-min.js"></script>
    <title>Ejercicio 5</title>
</head>
<body onload="init()">
    <canvas id="myCanvas" width="640" height="480"></canvas><br>
    <b>Decoration</b>
    <input type="radio" name="christmas" value="no" checked> No
    <input type="radio" name="christmas" value="yes"> Yes<br>
    <b>Rotation</b>
    <input type="checkbox" name="rotation" checked>
    <input type="range" id="speed" min="1" max="3" value="1" step="1"> Speed<br>
    <b>WebGL primitive</b>
    <input type="radio" name="primitive" value="triangles" checked> Triangles
    <input type="radio" name="primitive" value="lines"> Lines<br>
    <b>Projection type</b>
    <input type="radio" name="projection" value="perspective" checked> Perspective
    <input type="radio" name="projection" value="orthographic"> Orthographic<br>

    <script id="shaderVs" type="x-shader/x-vertex">
        attribute vec4 a_Position;
        attribute vec3 a_Color;
        attribute vec2 a_TexCoord;
        varying highp vec3 v_Color;
        varying highp vec2 v_TexCoord;

        uniform mat4 u_pMatrix;
        uniform mat4 u_vMatrix;
        uniform mat4 u_mvMatrix;

        void main(){
            gl_Position = u_pMatrix * u_vMatrix * u_mvMatrix * a_Position;
            v_Color = a_Color;
            v_TexCoord = a_TexCoord;
        }
    </script>

    <script id="shaderFs" type="x-shader/x-fragment">
        precision mediump float;
        varying highp vec3 v_Color;
        varying highp vec2 v_TexCoord;
        uniform sampler2D u_Sampler;

        void main(){
            vec4 texColor = texture2D(u_Sampler, v_TexCoord);
            gl_FragColor = texColor * vec4(v_Color, 1.0);
        }
    </script>

    <script>
        var gl,
            canvas,
            count = 0.0,
            ratio,
            z = 3,
            projectionValue = document.querySelector('input[name="projection"]:checked').value;

        function init(){
            // Get canvas object from the DOM and Init WebGL Context
            canvas = document.getElementById("myCanvas");
            gl = canvas.getContext("webgl");

            if (!gl) {
                console.log("FAILED TO GET THE RENDERING CONTEXT FOR WEBGL.");
                return;
            }

            // Init Shaders 
            var vs = document.getElementById('shaderVs').innerHTML,
                fs = document.getElementById('shaderFs').innerHTML;

            if (!initShaders(gl, vs, fs)){
                console.log("FAILED TO INITIALIZE SHADERS.");
                return;
            }

            // Init vertex shader
            initVertexShader(gl);

            // Init projection matrix
            initProjection(gl, canvas);

            // Set clear canvas color
            gl.clearColor(0.0, 0.0, 0.0, 1.0);

            // Hidden surface removal
            gl.enable(gl.DEPTH_TEST);

            // Event listener for mouse wheel
            document.addEventListener('wheel', function (event) {
                if (projectionValue == 'perspective'){
                    z = event.deltaY > 0 ? z - 1 : z + 1;
                }
            });

            // Event listener for radio buttons
            var christmasRadios = document.querySelectorAll('input[name="christmas"]');
            for (var i = 0; i < christmasRadios.length; i++) {
                christmasRadios[i].addEventListener('change', function() {
                    handleChristmasChange();
                });
            }

            // Event listener for projection type radio buttons
            var projectionRadios = document.querySelectorAll('input[name="projection"]');
            for (var i = 0; i < projectionRadios.length; i++) {
                projectionRadios[i].addEventListener('change', function() {
                    projectionValue = this.value;
                });
            }

            // Event listener for rotation checkbox
            document.querySelector('input[name="rotation"]').addEventListener('change', function() {
                initVertexShader(gl);
            });

            // Animation loop
            setInterval(drawScene, 16);
        }

        function handleChristmasChange() {
            // Handle change of Christmas decoration
            var christmasValue = document.querySelector('input[name="christmas"]:checked').value;
            if (christmasValue === 'yes') {
                // TODO: Apply Christmas texture
                // You need to load the texture and apply it here
            } else {
                // TODO: Apply regular texture
                // You need to load the regular texture and apply it here
            }
        }

        function initVertexShader(gl) {
            var rotation = document.querySelector('input[name="rotation"]').checked;
            var primitive = document.querySelector('input[name="primitive"]:checked').value;
            var speed = document.getElementById('speed').value;

            // 3D vertex coords array
            var vertices = new Float32Array([
                0.0,  1.0,  0.0,    1.0, 0.0, 0.0,  0.0, 1.0, // 0
                1.0, -1.0, -1.0,    1.0, 0.0, 0.0,  0.0, 0.0, // 1
                -1.0, -1.0, -1.0,   1.0, 0.0, 0.0,  1.0, 0.0, // 2
                1.0, -1.0,  1.0,    1.0, 0.0, 0.0,  1.0, 1.0, // 3
                -1.0, -1.0,  1.0,   1.0, 0.0, 0.0,  0.0, 1.0, // 4
                0.0,  1.0,  0.0,    1.0, 0.0, 0.0,  0.5, 1.0  // 5
            ]);

            // Vertex Indices array
            var indices = new Uint8Array([
                0, 1, 2,
                0, 3, 1,
                0, 4, 3,
                0, 2, 4,
                5, 2, 1,
                5, 1, 3,
                5, 3, 4,
                5, 4, 2
            ]);

            // Create a buffer object
            var vertexBuffer = gl.createBuffer();
            if (!vertexBuffer){
                console.log('FAILED TO CREATE THE BUFFER OBJECT.');
                return -1;
            }

            // Bind the buffer object to target
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            // Write data into the buffer object
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            // Assign the buffer object to a_Position variable
            var a_Position = gl.getAttribLocation(gl.program, 'a_Position');
            if (a_Position < 0){
                console.log('FAILED TO GET THE STORAGE LOCATION OF a_Position.');
                return -1;
            }
            gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 8 * vertices.BYTES_PER_ELEMENT, 0);
            gl.enableVertexAttribArray(a_Position);

            // Assign the buffer object to a_Color variable
            var a_Color = gl.getAttribLocation(gl.program, 'a_Color');
            if (a_Color < 0){
                console.log('FAILED TO GET THE STORAGE LOCATION OF a_Color.');
                return -1;
            }
            gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, 8 * vertices.BYTES_PER_ELEMENT, 3 * vertices.BYTES_PER_ELEMENT);
            gl.enableVertexAttribArray(a_Color);

            // Assign the buffer object to a_TexCoord variable
            var a_TexCoord = gl.getAttribLocation(gl.program, 'a_TexCoord');
            if (a_TexCoord < 0){
                console.log('FAILED TO GET THE STORAGE LOCATION OF a_TexCoord.');
                return -1;
            }
            gl.vertexAttribPointer(a_TexCoord, 2, gl.FLOAT, false, 8 * vertices.BYTES_PER_ELEMENT, 6 * vertices.BYTES_PER_ELEMENT);
            gl.enableVertexAttribArray(a_TexCoord);

            // Create an index buffer object
            var indexBuffer = gl.createBuffer();
            if (!indexBuffer){
                console.log('FAILED TO CREATE THE BUFFER OBJECT.');
                return -1;
            }
            // Bind the buffer object to target
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            // Write data into the buffer object
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

            // Create a texture object
            var texture = gl.createTexture();
            if (!texture) {
                console.log('FAILED TO CREATE THE TEXTURE OBJECT.');
                return false;
            }

            var u_Sampler = gl.getUniformLocation(gl.program, 'u_Sampler');
            if (!u_Sampler) {
                console.log('FAILED TO GET THE STORAGE LOCATION OF u_Sampler.');
                return false;
            }

            var image = new Image();
            image.onload = function() {
                loadTexture(gl, texture, u_Sampler, image);
            };
            image.src = 'path_to_your_texture_image.jpg';

            // Get the storage location of u_pMatrix
            var u_pMatrix = gl.getUniformLocation(gl.program, 'u_pMatrix');
            if (!u_pMatrix){
                console.log('FAILED TO GET THE STORAGE LOCATION OF u_pMatrix.');
                return;
            }

            // Get the storage location of u_vMatrix
            var u_vMatrix = gl.getUniformLocation(gl.program, 'u_vMatrix');
            if (!u_vMatrix){
                console.log('FAILED TO GET THE STORAGE LOCATION OF u_vMatrix.');
                return;
            }

            // Get the storage location of u_mvMatrix
            var u_mvMatrix = gl.getUniformLocation(gl.program, 'u_mvMatrix');
            if (!u_mvMatrix){
                console.log('FAILED TO GET THE STORAGE LOCATION OF u_mvMatrix.');
                return;
            }

            // Set the camera matrix
            var viewMatrix = mat4.create();
            mat4.lookAt(viewMatrix, [0, 1, z], [0, 0, 0], [0, 1, 0]);
            gl.uniformMatrix4fv(u_vMatrix, false, viewMatrix);

            // Set the projection matrix
            var pMatrix = mat4.create();
            if (projectionValue === 'perspective') {
                mat4.perspective(pMatrix, Math.PI/3, canvas.width/canvas.height, 1, 100);
            } else {
                mat4.ortho(pMatrix, -1, 1, -1, 1, 1, 100);
            }
            gl.uniformMatrix4fv(u_pMatrix, false, pMatrix);

            // Set the model-view matrix
            var mvMatrix = mat4.create();
            mat4.translate(mvMatrix, mvMatrix, [x, y, z]);
            if (rotation) {
                angle += speed;
                mat4.rotate(mvMatrix, mvMatrix, Math.PI / 180 * angle, [0, 1, 0]);
            }
            gl.uniformMatrix4fv(u_mvMatrix, false, mvMatrix);

            // Draw the cube
            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_BYTE, 0);
        }

        function drawScene() {
            var rotation = document.querySelector('input[name="rotation"]').checked;
            var speed = document.getElementById('speed').value;

            var canvas = document.getElementById('webgl');
            var gl = getWebGLContext(canvas);
            if (!gl) {
                console.log('FAILED TO GET THE RENDERING CONTEXT FOR WEBGL');
                return;
            }

            // Clear the canvas
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Enable the depth test
            gl.enable(gl.DEPTH_TEST);

            // Set the vertex shader and the fragment shader
            var program = createProgram(gl, VSHADER_SOURCE, FSHADER_SOURCE);
            if (!program) {
                console.log('FAILED TO CREATE THE PROGRAM.');
                return;
            }
            gl.useProgram(program);
            gl.program = program;

            // Load the vertex and the fragment shader
            if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) {
                console.log('FAILED TO INITIALIZE THE SHADERS.');
                return;
            }

            // Set the vertex shader and the fragment shader
            if (!initVertexShader(gl)) {
                console.log('FAILED TO INITIALIZE THE SHADERS.');
                return;
            }
        }

        function loadTexture(gl, texture, u_Sampler, image) {
            // Flip the image's y-axis
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
            // Enable texture unit0
            gl.activeTexture(gl.TEXTURE0);
            // Bind the texture object to the target
            gl.bindTexture(gl.TEXTURE_2D, texture);
            // Set the texture parameters
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            // Set the texture image
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);
            // Set the texture unit 0 to the sampler
            gl.uniform1i(u_Sampler, 0);
        }
    </script>
</body>
</html>
