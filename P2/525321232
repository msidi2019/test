<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <title>Ejercicio 5</title>
</head>

<body onload="init()">
    <canvas id="myCanvas" width="640" height="480"></canvas><br>
    <br>
    <b>Step:</b>
    <input type="text" value="0.1" id="step">
    <br>
    <b>Rotation</b>
    <input type="checkbox" name="rotation" checked>
    <input type="range" id="speed" min="1" max="3" value="1" step="1"><b>Speed</b><br>
    <b>WebGL primitive</b>
    <input type="radio" name="primitive" value="triangles" checked>Triangles
    <input type="radio" name="primitive" value="lines">Lines<br>
    <b>Projection type</b>
    <input type="radio" name="projection" value="perspective" checked> Perspective
    <input type="radio" name="projection" value="orthographic">Orthographic<br>
    <b>Daylight</b>
    <input type="radio" name="daylight" value="day" checked>Day
    <input type="radio" name="daylight" value="night">Night<br>
    <b>Decoration</b>
    <input type="radio" name="decoration" value="no" checked> No
    <input type="radio" name="decoration" value="yes"> Yes<br>
</body>

<script id="shaderVs" type="x-shader/x-vertex">
    attribute vec4 a_Position;
    attribute vec2 a_TexCoord;
    varying vec2 v_TexCoord;
    uniform mat4 u_pMatrix;
    uniform mat4 u_vMatrix;
    uniform mat4 u_mvMatrix;

    void main(){
        gl_Position = u_pMatrix * u_vMatrix * u_mvMatrix * a_Position;
        v_TexCoord = a_TexCoord;
    }
</script>

<script id="shaderFs" type="x-shader/x-fragment">
    precision mediump float;
    uniform sampler2D u_Sampler0;
    uniform sampler2D u_Sampler1;
    uniform float u_filter;
    varying vec2 v_TexCoord;
    uniform float u_Filter;

    void main(void) {
        vec4 color0 = texture2D(u_Sampler0, v_TexCoord);
        vec4 color1 = texture2D(u_Sampler1, v_TexCoord);

        if (u_Filter == 0.0){
            gl_FragColor = color0 * color1;
        } else {
            gl_FragColor = color0;
        }
    }
</script>

<script>
    var gl,
        canvas,
        count = 0.0,
        ratio,
        z = 3,
        axisY = 0.0,
        projectionValue,
        decorationValue = document.querySelector('input[name="decoration"]:checked').value;

    function init(){
        
        // Get canvas object from the DOM and Init WebGL Context
        canvas = document.getElementById("myCanvas");
        gl = canvas.getContext("webgl");

        if (!gl) {
            console.log("FAILED TO GET THE RENDERING CONTEXT FOR WEBGL.");
            return;
        }

        // Init Shaders 
        var vs = document.getElementById('shaderVs').innerHTML,
            fs = document.getElementById('shaderFs').innerHTML;

        if (!initShaders(gl, vs, fs)){
            console.log("FAILED TO INITIALIZE SHADERS.");
            return;
        }

        // Init vertex shader
        initVertexShader(gl);

        // Init projection matrix
        initProjection(gl, canvas);

        // Set clear canvas color
        gl.clearColor(0.0, 0.0, 0.0, 1.0);

        // Hidden surface removal
        gl.enable(gl.DEPTH_TEST);

        // Event listener for mouse wheel
        document.addEventListener('wheel', function (event) {
            if (projectionValue == 'perspective'){
                z = event.deltaY > 0 ? z - 1 : z + 1;
            }
        });
    }

    document.onkeydown = function (ev) {
        var step = parseFloat(document.getElementById("step").value);

        switch (ev.keyCode) {         
            case 38: // Up
                axisY += step;
                console.log('UP CAMERA');
                break;
            
            case 40: // Down
                axisY -= step;
                console.log('DOWN CAMERA');
                break;
            
            default:
                // If you press another key --> ¡ERROR!
                console.log('¡ERROR!: You are not pressing the correct key.');
                step = 0.0;
                break;
            }
    }

    function drawScene() {
        gl.clear(gl.COLOR_BUFFER_BIT);
      
        projectionValue = document.querySelector('input[name="projection"]:checked').value, 
        daylightValue = document.querySelector('input[name="daylight"]:checked').value,      
        u_pMatrix = gl.getUniformLocation(gl.program, "u_pMatrix"),
        u_vMatrix = gl.getUniformLocation(gl.program, "u_vMatrix"),
        ratio = canvas.width/canvas.height;
        
        switch (projectionValue) {
            case "perspective":
                var pMatrix = mat4.perspective(mat4.create(), toRadian(60), ratio, 0.1, 100),
                    vMatrix = mat4.lookAt(mat4.create(), [0, axisY, z], [0, 0, 0], [0, 1, 0]);
                break;
        
            case "orthographic":
                var pMatrix = mat4.ortho(mat4.create(), -ratio, ratio, -1.0, 1.50, -1.0, 1.50),
                    vMatrix = mat4.create();
                break;
            default:
        }

        gl.uniformMatrix4fv(u_pMatrix, false, pMatrix);
        gl.uniformMatrix4fv(u_vMatrix, false, vMatrix);

        switch(daylightValue){
            case "day":
                var u_Filter = gl.getUniformLocation(gl.program, "u_Filter");
                gl.uniform1f(u_Filter, 1);
                break;

            case "night":
                var u_Filter = gl.getUniformLocation(gl.program, "u_Filter");
                gl.uniform1f(u_Filter, 0);
                break;
            default:
        }

        // Get the location of attributes variables
        var a_Position = gl.getAttribLocation(gl.program, 'a_Position'),
            a_TexCoord = gl.getAttribLocation(gl.program, 'a_TexCoord');

        // Set texture
        var u_Sampler0 = gl.getUniformLocation(gl.program, 'u_Sampler0'),
            u_Sampler1 = gl.getUniformLocation(gl.program, 'u_Sampler1');

        var texture0 = gl.createTexture(),
            texture1 = gl.createTexture(),
            img0 = new Image(),
            img1 = new Image();

        img0.onload = function() {
            loadTexture(gl, 0, texture0, img0, u_Sampler0);
        };

        img1.onload = function() {
            loadTexture(gl, 1, texture1, img1, u_Sampler1);
        };

        img0.src = 'textures/portal.jpg';
        img1.src = 'textures/light.jpg';

        if (decorationValue == 'yes'){
            // Set texture coordinates
            var verticesTexCoords = new Float32Array([
                -1.0, 1.0,   0.0, 1.0,
                -1.0, -1.0,  0.0, 0.0,
                1.0, 1.0,    1.0, 1.0,
                1.0, -1.0,   1.0, 0.0,
            ]);
    
            var n = 4;

            var vertexTexCoordBuffer = gl.createBuffer();
            if (!vertexTexCoordBuffer) {
                console.log('Failed to create the buffer object');
                return -1;
            }

            gl.bindBuffer(gl.ARRAY_BUFFER, vertexTexCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, verticesTexCoords, gl.STATIC_DRAW);
    
            var FSIZE = verticesTexCoords.BYTES_PER_ELEMENT;
    
            gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, FSIZE * 4, 0);
            gl.enableVertexAttribArray(a_Position);
    
            gl.vertexAttribPointer(a_TexCoord, 2, gl.FLOAT, false, FSIZE * 4, FSIZE * 2);
            gl.enableVertexAttribArray(a_TexCoord);

            gl.bindBuffer(gl.ARRAY_BUFFER, null);
        }

        // Clearing Canvas
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        
        if (projectionValue == 'orthographic'){
            mat4.rotateY(vMatrix, vMatrix, count);
        }
        
        // Drawing with the selected primitive
        if (projectionValue == 'perspective'){
            count += 0.01 * document.getElementById('speed').value;
        } else {
            count += 0.01;
        }
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, n);
        requestAnimationFrame(drawScene);
    }

    function loadTexture(gl, index, texture, image, u_Sampler) {
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
        gl.activeTexture(gl['TEXTURE' + index]);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);
        gl.uniform1i(u_Sampler, index);
        gl.clear(gl.COLOR_BUFFER_BIT);
    }

    function initVertexShader(gl){
        var verticesTexCoords = new Float32Array([
            -0.5, 0.5, 0.0, 1.0,
            -0.5, -0.5, 0.0, 0.0,
            0.5, 0.5, 1.0, 1.0,
            0.5, -0.5, 1.0, 0.0
        ]);

        var n = 4;
        var vertexTexCoordBuffer = gl.createBuffer();
        if (!vertexTexCoordBuffer) {
            console.log('Failed to create the buffer object');
            return -1;
        }

        gl.bindBuffer(gl.ARRAY_BUFFER, vertexTexCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, verticesTexCoords, gl.STATIC_DRAW);

        var FSIZE = verticesTexCoords.BYTES_PER_ELEMENT;

        var a_Position = gl.getAttribLocation(gl.program, 'a_Position');
        var a_TexCoord = gl.getAttribLocation(gl.program, 'a_TexCoord');

        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, FSIZE * 4, 0);
        gl.enableVertexAttribArray(a_Position);

        gl.vertexAttribPointer(a_TexCoord, 2, gl.FLOAT, false, FSIZE * 4, FSIZE * 2);
        gl.enableVertexAttribArray(a_TexCoord);

        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        return n;
    }

    function initProjection(gl, canvas){
        // Set the view port
        gl.viewport(0, 0, canvas.width, canvas.height);
    }

    function toRadian(degree){
        return degree * Math.PI / 180;
    }

    drawScene();
</script>
</html>
