<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <title>Ejercicio 5</title>
</head>

<body onload="init()">
    <canvas id="myCanvas" width="640" height="480"></canvas><br>
    <b>Rotation</b>
    <input type="checkbox" name="rotation" checked>
    <input type="range" id="speed" min="1" max="3" value="1" step="1"> Speed<br>
    <b>WebGL primitive</b>
    <input type="radio" name="primitive" value="triangles" checked> Triangles
    <input type="radio" name="primitive" value="lines"> Lines<br>
    <b>Projection type</b>
    <input type="radio" name="projection" value="perspective" checked> Perspective
    <input type="radio" name="projection" value="orthographic"> Orthographic<br>
    <b>Decoration</b>
    <input type="radio" name="christmas" value="no" checked> No
    <input type="radio" name="christmas" value="yes"> Yes<br>
    <b>Step</b>
    <input type="number" id="step" value="1" min="1" max="10">

    <script id="shaderVs" type="x-shader/x-vertex">
        attribute vec4 a_Position;
        attribute vec3 a_Color;
        attribute vec2 a_TexCoord; // Texture coordinates
        uniform mat4 u_pMatrix;
        uniform mat4 u_vMatrix;
        uniform mat4 u_mvMatrix;
        varying highp vec4 v_Color;
        varying highp vec2 v_TexCoord; // Varying for texture coordinates
        void main(){
            gl_Position = u_pMatrix * u_vMatrix * u_mvMatrix * a_Position;
            v_Color = vec4(a_Color, 1.0);
            v_TexCoord = a_TexCoord; // Pass texture coordinates to fragment shader
        }
    </script>

    <script id="shaderFs" type="x-shader/x-fragment">
        precision mediump float;
        varying highp vec4 v_Color;
        varying highp vec2 v_TexCoord; // Varying for texture coordinates
        uniform sampler2D u_Sampler; // Texture sampler
        uniform sampler2D u_DecorationSampler; // Decoration texture sampler
        void main(){
            vec4 texColor = texture2D(u_Sampler, v_TexCoord);
            if (texColor.a < 0.5) discard; // Discard transparent pixels
            if (u_DecorationSampler != 0) {
                vec4 decorationColor = texture2D(u_DecorationSampler, v_TexCoord);
                gl_FragColor = texColor * decorationColor;
            } else {
                gl_FragColor = texColor * v_Color;
            }
        }
    </script>

    <script>
        var gl,
            canvas,
            count = 0.0,
            ratio,
            z = 3,
            projectionValue = document.querySelector('input[name="projection"]:checked').value,
            textures = {}; // Objeto para almacenar las texturas cargadas

        function init(){
            // Get canvas object from the DOM and Init WebGL Context
            canvas = document.getElementById("myCanvas");
            gl = canvas.getContext("webgl");

            if (!gl) {
                console.log("FAILED TO GET THE RENDERING CONTEXT FOR WEBGL.");
                return;
            }

            // Init Shaders 
            var vs = document.getElementById('shaderVs').innerHTML,
                fs = document.getElementById('shaderFs').innerHTML;

            if (!initShaders(gl, vs, fs)){
                console.log("FAILED TO INITIALIZE SHADERS.");
                return;
            }

            // Init vertex shader
            initVertexShader(gl);

            // Init projection matrix
            initProjection(gl, canvas);

            // Set clear canvas color
            gl.clearColor(0.0, 0.0, 0.0, 1.0);

            // Hidden surface removal
            gl.enable(gl.DEPTH_TEST);

            // Event listener for mouse wheel
            document.addEventListener('wheel', function (event) {
                if (projectionValue == 'perspective'){
                    z = event.deltaY > 0 ? z - 1 : z + 1;
                }
            });

            // Event listener for radio buttons
            document.querySelectorAll('input[type="radio"]').forEach(function(radio) {
                radio.addEventListener('change', function() {
                    if (this.name === 'christmas') {
                        applyDecoration(this.value === 'yes');
                    }
                });
            });

            // Event listener for keyboard input
            document.addEventListener('keydown', function(event) {
                var step = parseInt(document.getElementById("step").value);
                switch(event.key) {
                    case 'ArrowUp':
                        moveCameraUp(step);
                        break;
                    case 'ArrowDown':
                        moveCameraDown(step);
                        break;
                    default:
                        break;
                }
            });

            initTextures(); // Load textures
            drawScene(); // Initial drawing
        }

        function initTextures() {
            textures.portal = loadTexture('portal.jpg', function() {
                // Texture loaded callback (if needed)
                drawScene(); // Redraw after texture loaded
            });
            textures.light = loadTexture('light.jpg', function() {
                // Texture loaded callback (if needed)
                drawScene(); // Redraw after texture loaded
            });
        }

        function loadTexture(url, callback) {
            var texture = gl.createTexture();
            texture.image = new Image();
            texture.image.onload = function() {
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
                gl.generateMipmap(gl.TEXTURE_2D);
                gl.bindTexture(gl.TEXTURE_2D, null);
                if (callback) callback();
            }
            texture.image.src = url;
            return texture;
        }

        function initVertexShader(gl) {
            // Vertex shader initialization
            var texCoordLocation = gl.getAttribLocation(gl.program, 'a_TexCoord');
            gl.enableVertexAttribArray(texCoordLocation);

            // Configure texture coordinate buffer
            var texCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                // Texture coordinates for each vertex
                // Adjust these coordinates to fit your texture mapping
            ]), gl.STATIC_DRAW);
            gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
        }

        function applyDecoration(apply) {
            drawScene();
        }

        function moveCameraUp(step) {
            // Implement camera movement up
            drawScene();
        }

        function moveCameraDown(step) {
            // Implement camera movement down
            drawScene();
        }

        function drawScene(){
            // Clear canvas
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Set the camera position
            var viewMatrix = mat4.create();
            var eye = vec3.fromValues(0.0, 0.0, z),
                center = vec3.fromValues(0.0, 0.0, 0.0),
                up = vec3.fromValues(0.0, 1.0, 0.0);
            mat4.lookAt(viewMatrix, eye, center, up);

            // Set projection matrix
            var pMatrix = mat4.create();
            if (projectionValue === 'perspective') {
                mat4.perspective(pMatrix, Math.PI / 4, ratio, 0.1, 100.0);
            } else if (projectionValue === 'orthographic') {
                mat4.ortho(pMatrix, -1.0 * ratio, 1.0 * ratio, -1.0, 1.0, 0.1, 100.0);
            }

            // Set model view matrix
            var mvMatrix = mat4.create();
            mat4.translate(mvMatrix, mvMatrix, [0.0, 0.0, -5.0]);
            mat4.rotate(mvMatrix, mvMatrix, count, [0.0, 1.0, 0.0]);

            // Pass matrices to the shader
            gl.uniformMatrix4fv(gl.getUniformLocation(gl.program, "u_pMatrix"), false, pMatrix);
            gl.uniformMatrix4fv(gl.getUniformLocation(gl.program, "u_vMatrix"), false, viewMatrix);
            gl.uniformMatrix4fv(gl.getUniformLocation(gl.program, "u_mvMatrix"), false, mvMatrix);

            // Drawing logic
            // Bind the appropriate texture before drawing each object
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textures.portal);
            gl.uniform1i(gl.getUniformLocation(gl.program, 'u_Sampler'), 0);
            // Draw the object

            // For the decoration texture
            if (document.querySelector('input[name="christmas"]:checked').value === 'yes') {
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, textures.light);
                gl.uniform1i(gl.getUniformLocation(gl.program, 'u_DecorationSampler'), 1);
            }

            // Increment rotation angle
            if (document.querySelector('input[name="rotation"]').checked) {
                var speed = parseFloat(document.getElementById("speed").value);
                count += 0.05 * speed;
            }

            // Redraw
            requestAnimationFrame(drawScene);
        }

        function initProjection(gl, canvas){
            ratio = canvas.width / canvas.height;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        function initShaders(gl, vs, fs){
            var vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vs);
            gl.compileShader(vertexShader);
            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                console.error('ERROR compiling vertex shader!', gl.getShaderInfoLog(vertexShader));
                return false;
            }

            var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fs);
            gl.compileShader(fragmentShader);
            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                console.error('ERROR compiling fragment shader!', gl.getShaderInfoLog(fragmentShader));
                return false;
            }

            // Create shader program
            gl.program = gl.createProgram();
            gl.attachShader(gl.program, vertexShader);
            gl.attachShader(gl.program, fragmentShader);
            gl.linkProgram(gl.program);
            if (!gl.getProgramParameter(gl.program, gl.LINK_STATUS)) {
                console.error('ERROR linking program!', gl.getProgramInfoLog(gl.program));
                return false;
            }

            gl.useProgram(gl.program);
            return true;
        }
    </script>
</body>
</html>
