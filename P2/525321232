<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <title>Ejercicio 5</title>
</head>

<body onload="init()">
    <canvas id="myCanvas" width="640" height="480"></canvas><br>
    <b>Rotation</b>
    <input type="checkbox" name="rotation" checked>
    <input type="range" id="speed" min="1" max="3" value="1" step="1"> Speed<br>
    <b>WebGL primitive</b>
    <input type="radio" name="primitive" value="triangles" checked> Triangles
    <input type="radio" name="primitive" value="lines"> Lines<br>
    <b>Projection type</b>
    <input type="radio" name="projection" value="perspective" checked> Perspective
    <input type="radio" name="projection" value="orthographic"> Orthographic<br>
    <b>Decoration</b>
    <input type="radio" name="decoration" value="no" checked> No
    <input type="radio" name="decoration" value="yes"> Yes<br>
    <label for="step">Step value:</label>
    <input type="number" id="step" name="step" value="0.1" min="0.1" max="10" step="0.1"><br>

    <script id="shaderVs" type="x-shader/x-vertex">
        attribute vec4 a_Position;
        attribute vec3 a_Color;
        attribute vec2 a_TexCoord;
        varying highp vec4 v_Color;
        varying highp vec2 v_TexCoord;
        uniform mat4 u_pMatrix;
        uniform mat4 u_vMatrix;
        uniform mat4 u_mvMatrix;
        void main() {
            gl_Position = u_pMatrix * u_vMatrix * u_mvMatrix * a_Position;
            v_Color = vec4(a_Color, 1.0);
            v_TexCoord = a_TexCoord;
        }
    </script>

    <script id="shaderFs" type="x-shader/x-fragment">
        varying highp vec4 v_Color;
        varying highp vec2 v_TexCoord;
        uniform sampler2D u_Texture;
        uniform int u_ApplyDecoration;

        void main() {
            if (u_ApplyDecoration == 1) {
                gl_FragColor = texture2D(u_Texture, v_TexCoord);
            } else {
                gl_FragColor = v_Color;
            }
        }
    </script>

    <script>
        var gl,
            canvas,
            count = 0.0,
            ratio,
            z = 3,
            projectionValue = document.querySelector('input[name="projection"]:checked').value,
            decorationValue = document.querySelector('input[name="decoration"]:checked').value,
            textureImage1 = new Image(),
            textureImage2 = new Image(),
            texture1,
            texture2;

        textureImage1.src = 'portal.jpg'; // Textura para el arco
        textureImage2.src = 'light.jpg'; // Segunda textura para el arco

        textureImage1.onload = function() {
            texture1 = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture1);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImage1);
            gl.generateMipmap(gl.TEXTURE_2D);
            gl.bindTexture(gl.TEXTURE_2D, null);
        };

        textureImage2.onload = function() {
            texture2 = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture2);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImage2);
            gl.generateMipmap(gl.TEXTURE_2D);
            gl.bindTexture(gl.TEXTURE_2D, null);
        };

        function init() {
            // Get canvas object from the DOM and Init WebGL Context
            canvas = document.getElementById("myCanvas");
            gl = canvas.getContext("webgl");

            if (!gl) {
                console.log("FAILED TO GET THE RENDERING CONTEXT FOR WEBGL.");
                return;
            }

            // Init Shaders 
            var vs = document.getElementById('shaderVs').innerHTML,
                fs = document.getElementById('shaderFs').innerHTML;

            if (!initShaders(gl, vs, fs)) {
                console.log("FAILED TO INITIALIZE SHADERS.");
                return;
            }

            // Init vertex shader
            initVertexShader(gl);

            // Init projection matrix
            initProjection(gl, canvas);

            // Set clear canvas color
            gl.clearColor(0.0, 0.0, 0.0, 1.0);

            // Hidden surface removal
            gl.enable(gl.DEPTH_TEST);

            // Event listener for mouse wheel
            document.addEventListener('wheel', function(event) {
                if (projectionValue == 'perspective') {
                    z = event.deltaY > 0 ? z - 1 : z + 1;
                }
            });

            // Event listener for radio buttons
            var decorationRadios = document.getElementsByName('decoration');
            for (var i = 0; i < decorationRadios.length; i++) {
                decorationRadios[i].addEventListener('change', function() {
                    decorationValue = this.value;
                });
            }

            // Event listener for keyboard input
            document.addEventListener('keydown', function(event) {
                var step = parseFloat(document.getElementById("step").value);
                switch (event.key) {
                    case 'ArrowUp':
                        elevateCamera(step);
                        break;
                    case 'ArrowDown':
                        descendCamera(step);
                        break;
                    default:
                        break;
                }
            });

            drawScene();
        }

        function drawScene() {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            projectionValue = document.querySelector('input[name="projection"]:checked').value;
            var u_pMatrix = gl.getUniformLocation(gl.program, "u_pMatrix"),
                u_vMatrix = gl.getUniformLocation(gl.program, "u_vMatrix"),
                ratio = canvas.width / canvas.height;

            var pMatrix, vMatrix;
            switch (projectionValue) {
                case "perspective":
                    pMatrix = mat4.perspective(mat4.create(), toRadian(60), ratio, 0.1, 100);
                    vMatrix = mat4.lookAt(mat4.create(), [0, 0, z], [0, 0, 0], [0, 1, 0]);
                    break;
                case "orthographic":
                    pMatrix = mat4.ortho(mat4.create(), -ratio, ratio, -1.0, 1.50, -1.0, 1.50);
                    vMatrix = mat4.lookAt(mat4.create(), [0, 0, z], [0, 0, 0], [0, 1, 0]);
                    break;
                default:
                    break;
            }

            gl.uniformMatrix4fv(u_pMatrix, false, pMatrix);
            gl.uniformMatrix4fv(u_vMatrix, false, vMatrix);

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            drawCube();
            count += parseFloat(document.getElementById("speed").value);
            requestAnimationFrame(drawScene);
        }

        function drawCube() {
            var vertices = new Float32Array([
                -0.5, 0.5, -0.5,
                -0.5, -0.5, -0.5,
                0.5, -0.5, -0.5,
                0.5, 0.5, -0.5,
                -0.5, 0.5, 0.5,
                -0.5, -0.5, 0.5,
                0.5, -0.5, 0.5,
                0.5, 0.5, 0.5,
            ]);

            var colors = new Float32Array([
                1, 0, 0,
                1, 0, 0,
                1, 0, 0,
                1, 0, 0,
                1, 1, 0,
                1, 1, 0,
                1, 1, 0,
                1, 1, 0,
            ]);

            var texCoords = new Float32Array([
                0, 1,
                0, 0,
                1, 0,
                1, 1,
                0, 1,
                0, 0,
                1, 0,
                1, 1,
            ]);

            var indices = new Uint8Array([
                0, 1, 2, 0, 2, 3,
                4, 5, 6, 4, 6, 7,
                0, 3, 7, 0, 7, 4,
                1, 2, 6, 1, 6, 5,
                0, 4, 5, 0, 5, 1,
                2, 3, 7, 2, 7, 6,
            ]);

            var vertexBuffer = gl.createBuffer(),
                colorBuffer = gl.createBuffer(),
                texCoordBuffer = gl.createBuffer(),
                indexBuffer = gl.createBuffer();

            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            var a_Position = gl.getAttribLocation(gl.program, "a_Position");
            gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(a_Position);

            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
            var a_Color = gl.getAttribLocation(gl.program, "a_Color");
            gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(a_Color);

            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);
            var a_TexCoord = gl.getAttribLocation(gl.program, "a_TexCoord");
            gl.vertexAttribPointer(a_TexCoord, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(a_TexCoord);

            gl.activeTexture(gl.TEXTURE0);
            if (decorationValue == 'yes' && texture1 && texture2) {
                gl.bindTexture(gl.TEXTURE_2D, texture2);
                var u_Texture = gl.getUniformLocation(gl.program, "u_Texture");
                gl.uniform1i(u_Texture, 0);
                gl.uniform1i(gl.getUniformLocation(gl.program, "u_ApplyDecoration"), 1);
            } else {
                gl.bindTexture(gl.TEXTURE_2D, null);
                gl.uniform1i(gl.getUniformLocation(gl.program, "u_ApplyDecoration"), 0);
            }

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_BYTE, 0);
        }

        function initProjection(gl, canvas) {
            var u_pMatrix = gl.getUniformLocation(gl.program, "u_pMatrix");
            var projection = mat4.perspective(mat4.create(), toRadian(60), canvas.width / canvas.height, 0.1, 100);
            gl.uniformMatrix4fv(u_pMatrix, false, projection);
        }

        function initVertexShader(gl) {
            var a_Position = gl.getAttribLocation(gl.program, "a_Position");
            var a_Color = gl.getAttribLocation(gl.program, "a_Color");
            var a_TexCoord = gl.getAttribLocation(gl.program, "a_TexCoord");
            if (a_Position < 0 || a_Color < 0 || a_TexCoord < 0) {
                console.log("FAILED TO GET THE STORAGE LOCATION OF a_Position, a_Color, OR a_TexCoord.");
                return;
            }
        }

        function toRadian(angle) {
            return angle * Math.PI / 180;
        }

        function elevateCamera(step) {
            z -= step;
        }

        function descendCamera(step) {
            z += step;
        }
    </script>
</body>

</html>

