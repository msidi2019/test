<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <title>Ejercicio 5</title>
</head>

<body onload="init()">
    <canvas id="myCanvas" width="640" height="480"></canvas><br>
    <b>Rotation</b>
    <input type="checkbox" name="rotation" checked>
    <input type="range" id="speed" min="1" max="3" value="1" step="1"> Speed<br>
    <b>WebGL primitive</b>
    <input type="radio" name="primitive" value="triangles" checked> Triangles
    <input type="radio" name="primitive" value="lines"> Lines<br>
    <b>Projection type</b>
    <input type="radio" name="projection" value="perspective" checked> Perspective
    <input type="radio" name="projection" value="orthographic"> Orthographic<br>
    <b>Decoration</b>
    <input type="radio" name="christmas" value="no" checked> No
    <input type="radio" name="christmas" value="yes"> Yes<br>

    <script id="shaderVs" type="x-shader/x-vertex">
        attribute vec4 a_Position;
        attribute vec3 a_Color;
        attribute vec2 a_TexCoord;
        varying vec3 v_Color;
        varying highp vec2 v_TexCoord;
        uniform mat4 u_pMatrix;
        uniform mat4 u_vMatrix;
        uniform mat4 u_mvMatrix;
        void main(){
            gl_Position = u_pMatrix * u_vMatrix * u_mvMatrix * a_Position;
            v_Color = a_Color;
            v_TexCoord = a_TexCoord;
        }
    </script>

    <script id="shaderFs" type="x-shader/x-fragment">
        precision mediump float;
        varying vec3 v_Color;
        varying highp vec2 v_TexCoord;
        uniform sampler2D u_Sampler0;
        uniform sampler2D u_Sampler1;
        uniform float u_Filter;
        void main(void) {
            vec4 color0 = texture2D(u_Sampler0, v_TexCoord);
            vec4 color1 = texture2D(u_Sampler1, v_TexCoord);
            
            if (u_Filter == 0.0){
                gl_FragColor = color0 * color1;
            }else{
                gl_FragColor = color0;
            }
        }
    </script>

    <script>
        var gl,
            canvas,
            count = 0.0,
            ratio,
            z = 3,
            axisY = 0.0; 

        function init(){
            
            // Get canvas object from the DOM and Init WebGL Context
            canvas = document.getElementById("myCanvas");
            gl = canvas.getContext("webgl");

            if (!gl) {
            console.log("FAILED TO GET THE RENDERING CONTEXT FOR WEBGL.");
            return;
            }

            // Init Shaders 
            var vs = document.getElementById('shaderVs').innerHTML,
                fs = document.getElementById('shaderFs').innerHTML;

            if (!initShaders(gl, vs, fs)){
            console.log("FAILED TO INITIALIZE SHADERS.");
            return;
            }

            initShaders(gl, vs, fs);

            // Init vertex shader
            initVertexShader(gl);

            // Init projection matrix
            initProjection(gl, canvas);

            // Set clear canvas color
            gl.clearColor(0.0, 0.0, 0.0, 1.0);

            // Hidden surface removal
            gl.enable(gl.DEPTH_TEST);

            // Init textures
            initTexturesAndDraw(gl);

            // Event listener for mouse wheel
            document.addEventListener('wheel', function (event) {
                projectionValue
                if (projectionValue == 'orthographic'){
                    z = event.wheelDelta > 0 ? z + 0 : z - 0;
                }else if (projectionValue == 'perspective'){
                    z = event.wheelDelta > 0 ? z + 1 : z - 1;
                }
            });

            document.onkeydown = function (ev) {
                var step = new Number(document.getElementById("step").value);

                switch (ev.keyCode) {         
                    case 38: // Up
                        axisY += step;
                        console.log('UP CAMERA');
                        break;
                    
                    case 40: // Down
                        axisY -= step;
                        console.log('DOWN CAMERA');
                        break;
                    
                    default:
                        console.log('Â¡ERROR!: You are not pressing the correct key.');
                        break;
                }
            };

            // Main render loop
            var tick = function () {
                count += 0.02;
                drawScene(gl);
                requestAnimationFrame(tick);
            };
            tick();
        }

        function initTexturesAndDraw(gl) {
            var texture0 = gl.createTexture();
            var texture1 = gl.createTexture();

            var image0 = new Image();
            var image1 = new Image();

            image0.onload = function () {
                handleLoadedTexture(image0, texture0);
            }
            image1.onload = function () {
                handleLoadedTexture(image1, texture1);
            }

            image0.src = 'portal.jpg';
            image1.src = 'light.jpg';
        }

        function handleLoadedTexture(image, texture) {
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
            gl.generateMipmap(gl.TEXTURE_2D);
            gl.bindTexture(gl.TEXTURE_2D, null);
        }

        function drawScene(gl){
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            // Define viewing and projection matrix
            var pMatrix = mat4.create(),
                mvMatrix = mat4.create(),
                vMatrix = mat4.create(),
                rotationMatrix = mat4.create();

            // Set projection matrix
            setProjection(gl, pMatrix);

            // Set view matrix
            mat4.lookAt(vMatrix, [0, 0, z], [0, 0, 0], [0, 1, 0]);
            
            // Set model-view matrix
            mat4.rotateY(mvMatrix, vMatrix, axisY);

            // Bind Buffer
            bindBuffer(gl);

            // Set uniforms
            setUniforms(gl, pMatrix, mvMatrix);

            // Draw primitive
            drawPrimitive(gl);
        }

        function setUniforms(gl, pMatrix, mvMatrix){
            var u_pMatrix = gl.getUniformLocation(gl.program, 'u_pMatrix'),
                u_vMatrix = gl.getUniformLocation(gl.program, 'u_vMatrix'),
                u_mvMatrix = gl.getUniformLocation(gl.program, 'u_mvMatrix'),
                u_Filter = gl.getUniformLocation(gl.program, 'u_Filter'),
                u_Sampler0 = gl.getUniformLocation(gl.program, 'u_Sampler0'),
                u_Sampler1 = gl.getUniformLocation(gl.program, 'u_Sampler1');

            // Set projection matrix
            gl.uniformMatrix4fv(u_pMatrix, false, pMatrix);

            // Set view matrix
            gl.uniformMatrix4fv(u_vMatrix, false, mvMatrix);

            // Set model-view matrix
            gl.uniformMatrix4fv(u_mvMatrix, false, mvMatrix);

            // Set filter value
            gl.uniform1f(u_Filter, getFilter());

            // Set texture units
            gl.uniform1i(u_Sampler0, 0);
            gl.uniform1i(u_Sampler1, 1);
        }

        function bindBuffer(gl){
            var a_Position = gl.getAttribLocation(gl.program, 'a_Position'),
                a_Color = gl.getAttribLocation(gl.program, 'a_Color'),
                a_TexCoord = gl.getAttribLocation(gl.program, 'a_TexCoord');

            // Bind vertex buffer object
            var vertexBuffer = gl.createBuffer(),
                colorBuffer = gl.createBuffer(),
                indexBuffer = gl.createBuffer(),
                textureBuffer = gl.createBuffer();

            if (!vertexBuffer || !colorBuffer || !indexBuffer || !textureBuffer){
                console.log("FAILED TO CREATE BUFFER OBJECT.");
                return;
            }

            // Bind vertex buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(a_Position);

            // Bind color buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
            gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(a_Color);

            // Bind texture buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);
            gl.vertexAttribPointer(a_TexCoord, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(a_TexCoord);

            // Bind index buffer
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
        }

        function getFilter() {
            return document.getElementsByName('christmas')[0].checked ? 0.0 : 1.0;
        }

        function setProjection(gl, pMatrix){
            var projectionValue = document.querySelector('input[name="projection"]:checked').value;

            if (projectionValue == 'orthographic'){
                mat4.ortho(pMatrix, -1, 1, -1, 1, 0.1, 100);
            }else if (projectionValue == 'perspective'){
                mat4.perspective(pMatrix, Math.PI/3, 640/480, 0.1, 100);
            }
        }

        function drawPrimitive(gl){
            var primitiveValue = document.querySelector('input[name="primitive"]:checked').value;

            if (primitiveValue == 'triangles'){
                gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_BYTE, 0);
            }else if (primitiveValue == 'lines'){
                gl.drawElements(gl.LINE_STRIP, indices.length, gl.UNSIGNED_BYTE, 0);
            }
        }
    </script>
</body>
</html>


