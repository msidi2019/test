<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <title>Ejercicio 5</title>
</head>

<body onload="init()">
    <canvas id="myCanvas" width="640" height="480"></canvas><br>
    <b>Rotation</b>
    <input type="checkbox" name="rotation" checked>
    <input type="range" id="speed" min="1" max="3" value="1" step="1"> Speed<br>
    <b>WebGL primitive</b>
    <input type="radio" name="primitive" value="triangles" checked> Triangles
    <input type="radio" name="primitive" value="lines"> Lines<br>
    <b>Projection type</b>
    <input type="radio" name="projection" value="perspective" checked> Perspective
    <input type="radio" name="projection" value="orthographic"> Orthographic<br>
    <b>Decoration</b>
    <input type="radio" name="christmas" value="no" checked> No
    <input type="radio" name="christmas" value="yes"> Yes<br>

    <script id="shaderVs" type="x-shader/x-vertex">
        attribute vec4 a_Position;
        attribute vec3 a_Color;
        attribute vec2 a_TexCoord; // Texture coordinates attribute
        varying highp vec3 v_Color;
        varying highp vec2 v_TexCoord; // Varying texture coordinates
        uniform mat4 u_pMatrix;
        uniform mat4 u_vMatrix;
        uniform mat4 u_mvMatrix;
        void main(){
            gl_Position = u_pMatrix * u_vMatrix * u_mvMatrix * a_Position;
            v_Color = a_Color;
            v_TexCoord = a_TexCoord; // Pass texture coordinates to fragment shader
        }
    </script>

    <script id="shaderFs" type="x-shader/x-fragment">
        precision mediump float;
        varying highp vec3 v_Color;
        varying highp vec2 v_TexCoord; // Receiving texture coordinates
        uniform sampler2D u_Sampler0; // Original texture sampler
        uniform sampler2D u_Sampler1; // New texture sampler
        uniform int u_Decoration; // Decoration control

        void main(void) {
            vec4 color0 = texture2D(u_Sampler0, v_TexCoord); // Original texture
            vec4 color1 = texture2D(u_Sampler1, v_TexCoord); // New texture
            
            if (u_Decoration == 1) {
                // Apply decoration
                gl_FragColor = color0 * color1;
            } else {
                // No decoration
                gl_FragColor = color0;
            }
        }
    </script>

    <script>
        var gl,
            canvas,
            count = 0.0,
            ratio,
            z = 3,
            projectionValue = document.querySelector('input[name="projection"]:checked').value;

        function init(){
            
            // Get canvas object from the DOM and Init WebGL Context
            canvas = document.getElementById("myCanvas");
            gl = canvas.getContext("webgl");

            if (!gl) {
                console.log("FAILED TO GET THE RENDERING CONTEXT FOR WEBGL.");
                return;
            }

            // Init Shaders 
            var vs = document.getElementById('shaderVs').innerHTML,
                fs = document.getElementById('shaderFs').innerHTML;

            if (!initShaders(gl, vs, fs)){
                console.log("FAILED TO INITIALIZE SHADERS.");
                return;
            }

            // Init vertex shader
            initVertexShader(gl);

            // Init projection matrix
            initProjection(gl, canvas);

            // Set clear canvas color
            gl.clearColor(0.0, 0.0, 0.0, 1.0);

            // Hidden surface removal
            gl.enable(gl.DEPTH_TEST);

            // Event listener for mouse wheel
            document.addEventListener('wheel', function (event) {
                if (projectionValue == 'perspective'){
                    z = event.deltaY > 0 ? z - 1 : z + 1;
                }
            });

            // Event listener for keyboard
            document.addEventListener('keydown', function (event) {
                if (event.keyCode == 65) // a key
                    count -= 0.01;
                else if (event.keyCode == 68) // d key
                    count += 0.01;
            });

            // Render Loop
            (function renderLoop(){
                initTexturesAndDraw();
                requestAnimationFrame(renderLoop);
            })();
        }

        function initTexturesAndDraw(){
            var texture = gl.createTexture();

            var u_Sampler0 = gl.getUniformLocation(gl.program, 'u_Sampler0'),
                u_Sampler1 = gl.getUniformLocation(gl.program, 'u_Sampler1'),
                u_Decoration = gl.getUniformLocation(gl.program, 'u_Decoration');

            var texture0 = new Image(),
                texture1 = new Image();

            // Load texture0
            texture0.onload = function () {
                loadTexture(gl, 0, texture0, u_Sampler0, texture, 0);
            };
            texture0.src = 'box.png';

            // Load texture1
            texture1.onload = function () {
                loadTexture(gl, 1, texture1, u_Sampler1, texture, 1);
            };
            texture1.src = 'decoration.png';

            // Draw
            draw();
        }

        function draw(){
            var u_pMatrix = gl.getUniformLocation(gl.program, 'u_pMatrix'),
                u_vMatrix = gl.getUniformLocation(gl.program, 'u_vMatrix'),
                u_mvMatrix = gl.getUniformLocation(gl.program, 'u_mvMatrix');

            var pMatrix = mat4.create(),
                vMatrix = mat4.create(),
                mvMatrix = mat4.create(),
                rotation = document.querySelector('input[name="rotation"]').checked;

            // Clear canvas and depth buffer
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Set projection matrix
            if (projectionValue === 'perspective') {
                mat4.perspective(pMatrix, Math.PI/4, ratio, 1, 10);
            } else {
                mat4.ortho(pMatrix, -1, 1, -1, 1, 1, 10);
            }

            // Set view matrix
            mat4.lookAt(vMatrix, [0, 0, z], [0, 0, 0], [0, 1, 0]);

            // Set model-view matrix
            mat4.translate(mvMatrix, mvMatrix, [0.0, 0.0, -5.0]);
            if (rotation) {
                mat4.rotate(mvMatrix, mvMatrix, count, [1, 1, 1]);
            }

            gl.uniformMatrix4fv(u_pMatrix, false, pMatrix);
            gl.uniformMatrix4fv(u_vMatrix, false, vMatrix);
            gl.uniformMatrix4fv(u_mvMatrix, false, mvMatrix);

            // Set decoration control
            var christmas = document.querySelector('input[name="christmas"]:checked').value;
            if (christmas === 'yes') {
                gl.uniform1i(u_Decoration, 1);
            } else {
                gl.uniform1i(u_Decoration, 0);
            }

            // Draw the geometry
            gl.drawArrays(gl.TRIANGLES, 0, 36);
        }

        function initVertexShader(gl){
            // Init vertex buffer
            var vertexBuffer = gl.createBuffer(),
                indexBuffer = gl.createBuffer(),
                textureBuffer = gl.createBuffer();

            // Cube vertices and colors
            var verticesColors = new Float32Array([
                // Vertex coordinates and color
                1.0,  1.0,  1.0,     1.0,  1.0,  1.0,
                -1.0,  1.0,  1.0,     1.0,  0.0,  0.0,
                -1.0, -1.0,  1.0,     1.0,  1.0,  0.0,
                1.0, -1.0,  1.0,     1.0,  1.0,  1.0,

                1.0,  1.0, -1.0,     1.0,  0.0,  1.0,
                -1.0,  1.0, -1.0,     0.0,  0.0,  1.0,
                -1.0, -1.0, -1.0,     0.0,  1.0,  1.0,
                1.0, -1.0, -1.0,     1.0,  0.0,  1.0,
            ]);

            // Texture coordinates
            var textureCoords = new Float32Array([
                // Texture coordinates
                0.0, 0.0,
                1.0, 0.0,
                1.0, 1.0,
                0.0, 1.0,
                1.0, 0.0,
                1.0, 1.0,
                0.0, 1.0,
                0.0, 0.0,
                0.0, 0.0,
                1.0, 0.0,
                1.0, 1.0,
                0.0, 1.0,
                0.0, 0.0,
                1.0, 0.0,
                1.0, 1.0,
                0.0, 1.0,
                0.0, 0.0,
                1.0, 0.0,
                1.0, 1.0,
                0.0, 1.0,
                0.0, 0.0,
                1.0, 0.0,
                1.0, 1.0,
                0.0, 1.0,
                0.0, 0.0,
                1.0, 0.0,
                1.0, 1.0,
                0.0, 1.0,
                0.0, 0.0,
                1.0, 0.0,
                1.0, 1.0,
                0.0, 1.0,
                0.0, 0.0,
                1.0, 0.0,
                1.0, 1.0,
                0.0, 1.0
            ]);

            // Indices
            var indices = new Uint8Array([
                0, 1, 2,   0, 2, 3,
                4, 5, 6,   4, 6, 7,
                8, 9, 10,  8, 10, 11,
                12, 13, 14, 12, 14, 15,
                16, 17, 18, 16, 18, 19,
                20, 21, 22, 20, 22, 23
            ]);

            // Init buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, verticesColors, gl.STATIC_DRAW);

            // Write vertex data to buffer object
            var FSIZE = verticesColors.BYTES_PER_ELEMENT;
            var a_Position = gl.getAttribLocation(gl.program, 'a_Position');
            gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 6, 0);
            gl.enableVertexAttribArray(a_Position);

            // Write texture data to buffer object
            gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, textureCoords, gl.STATIC_DRAW);
            var a_Texture = gl.getAttribLocation(gl.program, 'a_Texture');
            gl.vertexAttribPointer(a_Texture, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(a_Texture);

            // Bind index buffer
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
        }

        function initTexturesAndDraw(){
            var texture = gl.createTexture();

            var u_Sampler0 = gl.getUniformLocation(gl.program, 'u_Sampler0'),
                u_Sampler1 = gl.getUniformLocation(gl.program, 'u_Sampler1'),
                u_Decoration = gl.getUniformLocation(gl.program, 'u_Decoration');

            var texture0 = new Image(),
                texture1 = new Image();

            // Load texture0
            texture0.onload = function () {
                loadTexture(gl, 0, texture0, u_Sampler0, texture, 0);
            };
            texture0.src = 'box.png';

            // Load texture1
            texture1.onload = function () {
                loadTexture(gl, 1, texture1, u_Sampler1, texture, 1);
            };
            texture1.src = 'decoration.png';

            // Draw
            draw();
        }

        function draw(){
            var u_pMatrix = gl.getUniformLocation(gl.program, 'u_pMatrix'),
                u_vMatrix = gl.getUniformLocation(gl.program, 'u_vMatrix'),
                u_mvMatrix = gl.getUniformLocation(gl.program, 'u_mvMatrix');

            var pMatrix = mat4.create(),
                vMatrix = mat4.create(),
                mvMatrix = mat4.create(),
                rotation = document.querySelector('input[name="rotation"]').checked;

            // Clear canvas and depth buffer
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Set projection matrix
            if (projectionValue === 'perspective') {
                mat4.perspective(pMatrix, Math.PI/4, ratio, 1, 10);
            } else {
                mat4.ortho(pMatrix, -1, 1, -1, 1, 1, 10);
            }

            // Set view matrix
            mat4.lookAt(vMatrix, [0, 0, z], [0, 0, 0], [0, 1, 0]);

            // Set model-view matrix
            mat4.translate(mvMatrix, mvMatrix, [0.0, 0.0, -5.0]);
            if (rotation) {
                mat4.rotate(mvMatrix, mvMatrix, count, [1, 1, 1]);
            }

            gl.uniformMatrix4fv(u_pMatrix, false, pMatrix);
            gl.uniformMatrix4fv(u_vMatrix, false, vMatrix);
            gl.uniformMatrix4fv(u_mvMatrix, false, mvMatrix);

            // Set decoration control
            var christmas = document.querySelector('input[name="christmas"]:checked').value;
            if (christmas === 'yes') {
                gl.uniform1i(u_Decoration, 1);
            } else {
                gl.uniform1i(u_Decoration, 0);
            }

            // Draw the geometry
            gl.drawArrays(gl.TRIANGLES, 0, 36);
        }

        function initTexturesAndDraw(){
            var texture = gl.createTexture();

            var u_Sampler0 = gl.getUniformLocation(gl.program, 'u_Sampler0'),
                u_Sampler1 = gl.getUniformLocation(gl.program, 'u_Sampler1'),
                u_Decoration = gl.getUniformLocation(gl.program, 'u_Decoration');

            var texture0 = new Image(),
                texture1 = new Image();

            // Load texture0
            texture0.onload = function () {
                loadTexture(gl, 0, texture0, u_Sampler0, texture, 0);
            };
            texture0.src = 'box.png';

            // Load texture1
            texture1.onload = function () {
                loadTexture(gl, 1, texture1, u_Sampler1, texture, 1);
            };
            texture1.src = 'decoration.png';

            // Draw
            draw();
        }

        function draw(){
            var u_pMatrix = gl.getUniformLocation(gl.program, 'u_pMatrix'),
                u_vMatrix = gl.getUniformLocation(gl.program, 'u_vMatrix'),
                u_mvMatrix = gl.getUniformLocation(gl.program, 'u_mvMatrix');

            var pMatrix = mat4.create(),
                vMatrix = mat4.create(),
                mvMatrix = mat4.create(),
                rotation = document.querySelector('input[name="rotation"]').checked;

            // Clear canvas and depth buffer
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Set projection matrix
            if (projectionValue === 'perspective') {
                mat4.perspective(pMatrix, Math.PI/4, ratio, 1, 10);
            } else {
                mat4.ortho(pMatrix, -1, 1, -1, 1, 1, 10);
            }

            // Set view matrix
            mat4.lookAt(vMatrix, [0, 0, z], [0, 0, 0], [0, 1, 0]);

            // Set model-view matrix
            mat4.translate(mvMatrix, mvMatrix, [0.0, 0.0, -5.0]);
            if (rotation) {
                mat4.rotate(mvMatrix, mvMatrix, count, [1, 1, 1]);
            }

            gl.uniformMatrix4fv(u_pMatrix, false, pMatrix);
            gl.uniformMatrix4fv(u_vMatrix, false, vMatrix);
            gl.uniformMatrix4fv(u_mvMatrix, false, mvMatrix);

            // Set decoration control
            var christmas = document.querySelector('input[name="christmas"]:checked').value;
            if (christmas === 'yes') {
                gl.uniform1i(u_Decoration, 1);
            } else {
                gl.uniform1i(u_Decoration, 0);
            }

            // Draw the geometry
            gl.drawArrays(gl.TRIANGLES, 0, 36);
        }

        function initTexturesAndDraw(){
            var texture = gl.createTexture();

            var u_Sampler0 = gl.getUniformLocation(gl.program, 'u_Sampler0'),
                u_Sampler1 = gl.getUniformLocation(gl.program, 'u_Sampler1'),
                u_Decoration = gl.getUniformLocation(gl.program, 'u_Decoration');

            var texture0 = new Image(),
                texture1 = new Image();

            // Load texture0
            texture0.onload = function () {
                loadTexture(gl, 0, texture0, u_Sampler0, texture, 0);
            };
            texture0.src = 'box.png';

            // Load texture1
            texture1.onload = function () {
                loadTexture(gl, 1, texture1, u_Sampler1, texture, 1);
            };
            texture1.src = 'decoration.png';

            // Draw
            draw();
        }

        function draw(){
            var u_pMatrix = gl.getUniformLocation(gl.program, 'u_pMatrix'),
                u_vMatrix = gl.getUniformLocation(gl.program, 'u_vMatrix'),
                u_mvMatrix = gl.getUniformLocation(gl.program, 'u_mvMatrix');

            var pMatrix = mat4.create(),
                vMatrix = mat4.create(),
                mvMatrix = mat4.create(),
                rotation = document.querySelector('input[name="rotation"]').checked;

            // Clear canvas and depth buffer
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Set projection matrix
            if (projectionValue === 'perspective') {
                mat4.perspective(pMatrix, Math.PI/4, ratio, 1, 10);
            } else {
                mat4.ortho(pMatrix, -1, 1, -1, 1, 1, 10);
            }

            // Set view matrix
            mat4.lookAt(vMatrix, [0, 0, z], [0, 0, 0], [0, 1, 0]);

            // Set model-view matrix
            mat4.translate(mvMatrix, mvMatrix, [0.0, 0.0, -5.0]);
            if (rotation) {
                mat4.rotate(mvMatrix, mvMatrix, count, [1, 1, 1]);
            }

            gl.uniformMatrix4fv(u_pMatrix, false, pMatrix);
            gl.uniformMatrix4fv(u_vMatrix, false, vMatrix);
            gl.uniformMatrix4fv(u_mvMatrix, false, mvMatrix);

            // Set decoration control
            var christmas = document.querySelector('input[name="christmas"]:checked').value;
            if (christmas === 'yes') {
                gl.uniform1i(u_Decoration, 1);
            } else {
                gl.uniform1i(u_Decoration, 0);
            }

            // Draw the geometry
            gl.drawArrays(gl.TRIANGLES, 0, 36);
        }

        function initProjection(gl, canvas){
            ratio = canvas.width / canvas.height;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        function loadTexture(gl, textureUnit, textureImage, uniformSampler, texture, textureIndex){
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1); // Flip the image's y axis
            gl.activeTexture(gl.TEXTURE0 + textureUnit);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImage);
            gl.uniform1i(uniformSampler, textureUnit);
        }

        function initShaders(gl, vs, fs){
            // Create shader object
            var vertexShader = gl.createShader(gl.VERTEX_SHADER),
                fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

            // Attach shader source code
            gl.shaderSource(vertexShader, vs);
            gl.shaderSource(fragmentShader, fs);

            // Compile shaders
            gl.compileShader(vertexShader);
            gl.compileShader(fragmentShader);

            // Check for compilation errors
            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                console.error('ERROR compiling vertex shader!', gl.getShaderInfoLog(vertexShader));
                return false;
            }

            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                console.error('ERROR compiling fragment shader!', gl.getShaderInfoLog(fragmentShader));
                return false;
            }

            // Create program object
            gl.program = gl.createProgram();

            // Attach shaders to the program object
            gl.attachShader(gl.program, vertexShader);
            gl.attachShader(gl.program, fragmentShader);

            // Link program
            gl.linkProgram(gl.program);

            // Check for linking errors
            if (!gl.getProgramParameter(gl.program, gl.LINK_STATUS)) {
                console.error('ERROR linking program!', gl.getProgramInfoLog(gl.program));
                return false;
            }

            // Use the program object
            gl.useProgram(gl.program);

            return true;
        }
    </script>
</body>
</html>

